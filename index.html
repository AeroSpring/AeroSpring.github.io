<head>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined">
</head>
<body> 
  <div id="open-file-block">
    <label id="open_file_icon" for="file_input" class="material-icons-outlined">file_open</label>
    <br>
    <span id="file-input-info">Open file (.glb only)</span>
    <input id="file_input" type="file">
  </div>
  <canvas></canvas>
  <div id="dom-overlay">
    <div id="gizmo-block">
      <span id="move_icon" class="material-icons-outlined">open_with</span>
      <span id="rotate_icon" class="material-icons-outlined">autorenew</span>
      <span id="close_icon" class="material-icons-outlined">cancel</span> 
    </div>
  </div>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script type="module">
    
    // ИЗВЛЕЧЕНИЕ ТЕГОВ ИЗ РАЗМЕТКИ
    let canvas = window.document.querySelector('canvas');
    let domOverlay = window.document.querySelector('#dom-overlay');
    let gizmoBlock = window.document.querySelector('#gizmo-block');
    let moveIcon = window.document.querySelector('#move_icon');
    let rotateIcon = window.document.querySelector('#rotate_icon');
    let closeIcon = window.document.querySelector('#close_icon');
    let fileInput = window.document.querySelector('#file_input');
    let fileInputInfo = window.document.querySelector('#file-input-info');
    
    // СОЗДАНИЕ ДВИЖКА
    let engine = new BABYLON.Engine(canvas);
    
    // СОЗДАНИЕ СЦЕНЫ И ПРИСОЕДИНЕНИЕ ЕЁ К ДВИЖКУ
    let scene = new BABYLON.Scene(engine);
    scene.createDefaultEnvironment({
      createSkybox: false,
      createGround: false
    });
    
    // СОЗДАНИЕ СВЕТА
    let light = new BABYLON.PointLight('light', new BABYLON.Vector3(10, 10, -2), scene);
    light.intensity = 0.7;

    // ПОДКЛЮЧЕНИЕ WEBXR
    let xr = await scene.createDefaultXRExperienceAsync({
      uiOptions: {
        sessionMode: 'immersive-ar',
        referenceSpaceType: 'local-floor',
      }
    });
    let xrCamera = xr.baseExperience.camera;

    // ПОДКЛЮЧЕНИЕ DOM OVERLAY
    let featuresManager = xr.baseExperience.featuresManager;
    featuresManager.enableFeature(BABYLON.WebXRDomOverlay, 'latest', {element: '#dom-overlay'}, undefined, false);
    // ОТОБРАЖЕНИЕ DOM OVERLAY, ПОСЛЕ ПЕРЕХОДА В XR-РЕЖИМ
    xr.baseExperience.onStateChangedObservable.add((webXRState)=>{
      switch(webXRState){
        case BABYLON.WebXRState.IN_XR: {
          domOverlay.style.display = 'block';
          break;
        }
        case BABYLON.WebXRState.EXITING_XR: {
          domOverlay.style.display = 'none';
          break;
        }
        default: break;
      }
    });

    // ПОДКЛЮЧЕНИЕ GIZMO
    let gizmoManager = new BABYLON.GizmoManager(scene);
    // gizmoManager.attachableMeshes = [];



    // ПЕРЕМЕННЫЕ
    let activeElement = null;
    let editingElement = null;



    // ФУНКЦИИ

    // ФУНКЦИИ ДЛЯ GIZMO
    const clearGizmoOptions = () => {
      moveIcon.style.color = '#0096db';
      rotateIcon.style.color = '#0096db';
      gizmoManager.positionGizmoEnabled = false;
      gizmoManager.boundingBoxGizmoEnabled = false;
    }

    const setBoundingBox = (option) => {
      gizmoManager.boundingBoxGizmoEnabled = true;  
      gizmoManager.gizmos.boundingBoxGizmo.rotationSphereSize = 0;
      switch(option){
        case 'rotate': gizmoManager.gizmos.boundingBoxGizmo.rotationSphereSize = 0.03; break;
        default: break;
      }
      gizmoManager.gizmos.boundingBoxGizmo.updateBoundingBox();        
    }

    const setGizmoOption = (option) => {
      clearGizmoOptions();
      switch(option) {
        case 'move': {
          moveIcon.style.color = 'white';
          gizmoManager.positionGizmoEnabled = true;
          break;
        }
        case 'rotate': {
          rotateIcon.style.color = 'white';
          setBoundingBox(option);
          break;      
        }        
        default: break;
      }
    }

    const closeGizmo = (needDispose = false) => {
      clearGizmoOptions();
      gizmoManager._attachedMesh = null;
      gizmoManager.enableAutoPicking = true;
      gizmoBlock.style.display = 'none';
      (needDispose)
        ? editingElement.dispose()
        : editingElement = null;
    }



    engine.runRenderLoop(() => {
      if(activeElement) {
        activeElement.position = xrCamera.getFrontPosition(distance);
      }
      scene.render();
    });



    // ОБРАБОТЧИКИ СОБЫТИЙ
    fileInput.addEventListener('input', (event) => {
      if(event.target.files && event.target.files[0]){
        let reader = new FileReader();
        reader.addEventListener('load', (e) => {
          BABYLON.SceneLoader.Append('', e.target.result, scene, (loadedScene) => {
            fileInputInfo.innerText = event.target.files[0].name;
          });
        });
        reader.readAsDataURL(event.target.files[0]);
      }
    });

    // ОБРАБОТЧИКИ СОБЫТИЙ ДЛЯ GIZMO
    gizmoManager.onAttachedToMeshObservable.add((mesh) => {
      if(!activeElement){
        gizmoManager.enableAutoPicking = false;
        editingElement = mesh;
        //gizmoBlock.style.display = 'block';
        setGizmoOption('move');
      }else{
        gizmoManager._attachedMesh = null;
      }
    });
    moveIcon.addEventListener('click', (event) => setGizmoOption('move'));
    rotateIcon.addEventListener('click', (event) => setGizmoOption('rotate'));
    closeIcon.addEventListener('click', (event) => closeGizmo());

  </script>
</body>